本项目由行健车辆一袁朴真独立完成 
姓名：袁朴真 班级：行健车辆1 学号：2021012984 课程：5-3matlab与科学计算

运行方法：运行主程序start.m，再选择对应选项，进行求解的观看
建议分两个屏，一个放matlab窗口，一个放figure窗口，方便AI求解完后观看
两个AI求解完之后等待10s会自动再次生成新游戏，如果玩家游戏结束后需要手动选择是否进行下一盘
建议使用广度优先搜索的AI进行求解

主要完成了三个函数：AIhua深搜，AIhua2广搜，myhua玩家玩
AIhua   函数利用深度优先搜索的方法，获取可行解而非最优解，在解步数少时速度慢，但是解步数多时速度快于广搜
AIhua2 函数利用广度优先搜索的方法，获得最优解，在解步数较少时速度较快，但是当解步数多时求解速度慢
myhua 函数提供给玩家的交互功能，可以随机生成一种排布，用鼠标点击进行交互（点击不同部位有不同移动效果）
几个辅助函数：
start     	       文件类似于主函数，运行start函数可以选择所有功能，
drawinterface 函数对输入的矩阵绘制对应界面
drawblock      函数被drawinterface调用，画单个矩形方块
generatemap 函数用来随机生成矩阵，请注意可能会生成无解矩阵，用AI求解后会报no solution的错
node              类被AIhua与AIhua2调用，是tree存储的基本单元，下面会给出具体说明
	       在深搜中tree是一个栈，用一维元胞数组实现，广搜中由于实现deque较麻烦，故用二维元胞数组tree代替

基本数据结构说明：
用一个5*4的矩阵来记录当前位置，由于要区分不同小兵和武将，共用了10个数字
0：无人，1：曹操，2：黄忠，3：张飞，4：马超，5：赵云，6：关羽，7、8、9、10：不同小卒
例如经典关卡横刀立马的底层存储结构：
A1=[2 1 1 3;
       2 1 1 3;
       4 6 6 5;
       4 8 9 5;   
       7 0 0 10];

node类详细说明：
继承基类句柄handle不然不能改变成员变量
成员变量（公有）：
map 是当前的矩阵，用数字1-10代替角色player
movelist_can是所有可以采用的action，action=[player,direction]来表示动作，用元胞数组当数据结构
movelist_tried是已经采取过的action，仅在深搜中发挥作用，用元胞数组当数据结构
backnode是上一个结点，仅在广搜中起作用，类似于指针，用于回溯
成员函数（公有）：
function obj = node(A)为构造函数，用一个5*4矩阵构造node实例
function obj = addtry(obj,act)用于给实例中的movelist_tried增加action
function nextnode = next(obj,act)传入参数action后返回下一个结点
function num = iswin(obj)判断是否胜利的函数
function similist = similar(obj)返回一个列表，包含当前结点和镜像结点，该方法低效后来被弃用
function node2 = mirror(obj)返回镜像结点
function num = issame(obj,node)判断两个结点是否相同，默认2,3,4,5和7,8,9,10分别相同
function num = isin(obj,nodelist,listi)判断某个结点是否在一个结点列表nodelist的前listi项中，后一个参数主要用来提速
function show(obj)用来可视化一个结点，debug时使用

其他说明和感触：
深度优先搜索不适宜用来求最优解，仅仅是个人对数据结构的初步尝试，可以用来判断有无解
广度优先搜索较适宜用来求最优解，但是运行速度较慢，也尝试使用过gpu数组，但提速不大，故放弃
除此之外，还使用过预先分配数组内存，减少循环，矢量化编程等方法来进行提速，均在代码中有所体现
matlab本身是解释性语言，运算速度过慢，并且缺乏合适高效的数据结构，是AI求解速度慢的主要原因，个人认为matlab更适合画图
例如经典关卡A1“横刀立马”用深搜可用时15min，但不是最优解，用广搜可能用时将近1h
每次开始运行生成的矩阵纯随机，有可能无解，如果用步数在40步以内广搜求解较理想，可以马上得出最优解